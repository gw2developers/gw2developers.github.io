{"title":"Unit Testing the API","pubDate":"2014-02-23T21:32:59.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API","comments":[{"pubDate":"2014-03-20T17:37:51.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3785005","author":"Ruhrpottpatriot.7293","body":"\n<p>First here is the correct link Steven posted: </p><pre><code>http://gw2dotnet.codeplex.com/SourceControl/latest#GW2.NET-Http/GW2.NET Tests/V1/Core/Items/Details/ItemTest.cs</code></pre> (The forum cuts the url at the space it has and codeplex refuses to accept %20 or + as safe characters, please copy and past the url into your address bar)<p></p>\n<p>Another approach which I used in the early days of “GW2.NET”: <a href=\"https://gw2dotnet.codeplex.com/\">https://gw2dotnet.codeplex.com/</a> was the following:</p>\n<ul>\n\t<li>We know from the wiki which response to expect.</li>\n\t<li>You fetch the data which is preseted at the wiki and write your tests to compare it</li>\n\t<li>If your fetched data is equal to the data you have in the wiki (hardcode it into your tests or something) you know your code works.</li>\n</ul>\n<p>Another approach, since querying  some nodes (e.g. items.json) is time consuming, is to use mocking. Basically you pass the data to your method you know the api is going to return (in this case a JSON formatted string) and then work with that on your code. This is usually better than querying the api every time, since we expect the api to return data and it is not your responsibility to unit test the ANet api. So here is  what you would do:</p>\n<ul>\n\t<li>Take the data the api is going to return (from the api itself or otherwise) and pass it to your code via a mocking framework.</li>\n\t<li>Test your code with unit tests and the mocking framework.</li>\n</ul>\n<p>I personally recommend <a href=\"https://github.com/Moq/moq4\">Moq</a> as mocking framework and <a href=\"http://www.nunit.org/index.php?p=home\">NUnit</a> as testing framework. I have made great experience with both. But this is a personal preference use what ever you like.</p>","arenanet":false},{"pubDate":"2014-03-04T15:12:26.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3713260","author":"StevenL.3761","body":"\n<p>I took a slightly different approach. Rather than testing a particular response, I turn it into a JSON schema by replacing every value with a generic substitute.</p>\n<p><strong>numeric</strong> : 0<br>\n<strong>text</strong> : \"\"<br>\n<strong>collection</strong> : []<br>\n<strong>complex type</strong>: {}</p>\n<p>With that as the input, all I have to do is</p>\n<ol>\n\t<li>check that every object property is initialized to its default</li>\n\t<li>check that the serializer could find a matching property on the .NET class for every property in the JSON input.</li>\n</ol>\n<p>Example: <a href=\"https://gw2dotnet.codeplex.com/SourceControl/latest#GW2.NET-Http/GW2.NET\">https://gw2dotnet.codeplex.com/SourceControl/latest#GW2.NET-Http/GW2.NET</a> Tests/Core/ItemsInformation/Details/ItemTest.cs</p>","arenanet":false},{"pubDate":"2014-03-03T11:36:54.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3708698","author":"domness.6719","body":"\n<p>One solution we use with other projects is to run the tests, and the first time it will actually pull the data from the server and save this to the system. Any tests after this will just run tests on the downloaded JSON data (so only connects to the internet once, and once only).</p>\n<p>And then if you want to download the data again, we just delete the JSON files, and the tests automatically connect to the API again to re-pull data (in case anything may have changed, to check updated behaviour and such).</p>","arenanet":false},{"pubDate":"2014-02-28T18:15:39.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3700466","author":"Morhyn.8032","body":"\n<p>It’s quite easy — <a href=\"https://github.com/jsumners/gw2-api-client/blob/develop/src/test/java/com/jrfom/gw2/ItemDetailsTest.java\">https://github.com/jsumners/gw2-api-client/blob/develop/src/test/java/com/jrfom/gw2/ItemDetailsTest.java</a></p>","arenanet":false},{"pubDate":"2014-02-24T14:36:28.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3680972","author":"StevenL.3761","body":"\n<p>Alright, I think I get it now.</p>\n<p>My idea is to write individual tests for each ItemDetails property. One test to check that the target property isn’t <em>null</em>, and for properties where the range of allowed values is finite, one additional null-test per known value (e.g. ‘item_details.type’, ‘item_details.rarity’).</p>\n<p>Would that be a meaningful way to test?</p>","arenanet":false},{"pubDate":"2014-02-24T14:09:38.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3680857","author":"Killer Rhino.6794","body":"\n<blockquote><div class=\"quotey\"><p>So anyway, a test fixture is nothing but a vague description of a unit test that uses static sample data from an otherwise dynamic data source as input? I think that gave me an idea.</p></div></blockquote>\n<p>A <em>fixture</em> is the static sample data.</p>","arenanet":false},{"pubDate":"2014-02-24T12:37:41.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3680598","author":"StevenL.3761","body":"\n<p>Sorry, I wasn’t referring to the JSON’s response format. I remembered one of the devs talking about how they designed the APIs.</p>\n<blockquote><div class=\"citey\"><cite title=\"Posted on May 23 2013 10:48PM\"><a href=\"/forum/community/api/Possible-issue-with-buff-property/2081222\">Cliff Spradlin.3512:</a></cite></div><div class=\"quotey\"><p>I don’t have much experience using JSON libraries that map to strongly-typed objects. We didn’t really design the API in mind with that use-case, so I’m not surprised that there are places where it breaks or doesn’t make sense.</p></div></blockquote>\n<p>So anyway, a test fixture is nothing but a vague description of a unit test that uses static sample data from an otherwise dynamic data source as input? I think that gave me an idea.</p>","arenanet":false},{"pubDate":"2014-02-24T00:00:43.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3678970","author":"Killer Rhino.6794","body":"\n<blockquote><div class=\"quotey\"><p>If I’m not mistaken, the APIs we’re given are designed to be consumed in loosely typed languages.</p></div></blockquote>\n<p>You are mistaken. JSON is just a data exchange format which describes values. It does nothing to impose a specific “language” meant to consume it (yes, I realize that it originated from JavaScript). If JSON wasn’t as flexible as it is, and it was so restrictive as to make it difficult for developers of, say, statically type languages, to consume, it would not be so widely used.</p>\n<p>If a client application consumes JSON, and, for example, a value for ‘someID’ is passed down as a string, then if a programmer decides to convert that string value to an unsigned integer, so be it. That’s a architectural design decision, but this has nothing to do with the JSON concept or the provider of the APIs. If it works, it works.</p>\n<blockquote><div class=\"quotey\"><p>The problem is that I’m not exactly sure how to go about unit testing code that relies on external data.</p></div></blockquote>\n<p>Unit tests should be self-sustaining. You shouldn’t bake external dependencies within your tests, if you can help it. That that I recently solved this was with a testing concept called ‘fixtures’. A fixture can be considered pre-determined input passed into the unit test which mirror real-world data.</p>\n<p><em>Note: unit testing is a broad topic. Here, fixtures are present as just one possible solution. There are other alternatives, such as <a href=\"http://msdn.microsoft.com/en-us/library/ff650441.aspx\">mock objects</a>.</em></p>\n<p>I recent created a <a href=\"https://github.com/KevinVitale/GW2Kit/tree/development\">development</a> branch in <a href=\"https://github.com/KevinVitale/GW2Kit/\">GW2KIt</a> which adds a plethora of <a href=\"https://github.com/KevinVitale/GW2Kit/tree/development/Tests/Tests\">unit tests</a>. These tests use <a href=\"https://github.com/KevinVitale/GW2Kit/tree/development/Tests/Fixtures/v1\">fixtures</a> I created from version 1 (<em>v1</em>) of the APIs.</p>\n<p>Again, <a href=\"https://github.com/KevinVitale/GW2Kit/tree/development/Tests/Fixtures/v1\">look here for list of v1 fixtures</a> I use.</p>\n<p><strong>Edit</strong></p>\n<blockquote><div class=\"quotey\"><p>But what do I test for when an API’s response data changes over time due to the dynamic nature of the game?</p></div></blockquote>\n<p>You do your best to mitigate issues. “Doing your best” means combing the documentation, in this case <a href=\"http://wiki.guildwars2.com/wiki/API:1/item_details\">item_details</a>, and writing tests based on what’s described there. You might want to try making a fixture for one of each type of item, and running it through your unit test.</p>\n<p>If you’ve done your job correctly, you’ll be pretty well set. Then, it’s up to the API’s creators to communicate with the community about possible breaking changes. (Spoiler Alert: <a href=\"https://forum-en.guildwars2.com/forum/community/api/PSA-Attention-API-wrapper-authors/first#post3580692\">things will be changing soon</a>).</p>","arenanet":false},{"pubDate":"2014-02-23T21:33:00.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Unit-Testing-the-API/3678557","author":"StevenL.3761","body":"\n<p>Hello forum</p>\n<p>If I’m not mistaken, the APIs we’re given are designed to be consumed in loosely typed languages. Nevertheless, we successfully wrote a .NET library that wraps the API in strongly typed classes.</p>\n<p>The problem is that I’m not exactly sure how to go about unit testing code that relies on external data.</p>\n<p>For APIs that do not require any parameters, I can simply get the data once and use that to verify that my code behaves as expected.</p>\n<p>As an example, I test my code for the ‘items.json’ API like this:</p>\n<div class=\"spoiler_container\"><div class=\"spoileroncontainer\"><button type=\"button\" class=\"button spoileron\" title=\"Click to show the spoiler.\">Show Spoiler</button></div><div class=\"spoiler\"><div class=\"spoileroffcontainer\"><button type=\"button\" class=\"button spoileroff\" title=\"Click to hide the spoiler.\">hide spoiler</button><br></div><div class=\"spoilertext\"><pre><code>\n    [Test]\n    public void GetItemsCatalog()\n    {\n        var request  = new ItemsRequest();\n        var response = request.GetResponse(client);\n\n        Assume.That(response.IsSuccessStatusCode);\n        Assume.That(response.IsJsonResponse);\n\n        var itemsResult = response.Deserialize();\n\n        Assert.IsNotNull(itemsResult);\n        Assert.IsEmpty(itemsResult.ExtensionData, \"The '{0}' class is missing one or more properties.\", typeof(ItemsResult).FullName);\n\n        Assert.IsNotNull(itemsResult.Items);\n        Assert.IsNotEmpty(itemsResult.Items);\n        Assert.IsEmpty(itemsResult.Items.ExtensionData, \"The '{0}' class is missing one or more properties.\", typeof(Items).FullName);\n\n        Trace.WriteLine(string.Format(\"Number of items: {0}\", itemsResult.Items.Count));\n    }</code></pre></div></div></div><p>Although this unit test assumes that my machine has a working internet connection (and that the web service is up), its test results are fairly accurate. Either my code behaves as intended, or it doesn’t.</p>\n<p>But what do I test for when an API’s response data changes over time due to the dynamic nature of the game?</p>\n<p>At the time of writing, there are 31,864 unique item IDs that can be used to query the ‘item_details.json’ API. In order to say with 100% certainty that my ItemDetails class behaves as expected, I would have to test my code with 31,864 different inputs.</p>\n<p>Obviously, this is a no-go. So how do I test this code?</p>","arenanet":false}]}