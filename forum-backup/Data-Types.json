{"title":"Data Types","pubDate":"2015-01-17T12:36:00.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types","comments":[{"pubDate":"2015-02-05T08:11:51.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4766405","author":"Francis Crick.5021","body":"\n<p>The design data doesn’t use anything like a relational database, as Lawton mentioned.   It’s actually stored in a format fairly similar to what the API spits out, but we use guids to reference one object from another, and it’s quite a bit more verbose.  I’ll talk to Lawton about what we can do to generate schemas that you might find useful.  Everything does follow a schema, albeit an fairly complicated and ever evolving one.</p>","arenanet":false},{"pubDate":"2015-02-03T14:41:01.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4760903","author":"Dr Ishmael.9685","body":"\n<p>Ah, I see.  The only constraints I have in the database are on ID fields.  The way I went with lower-level validations like that was to check them within my API-to-DB object builders and note any errata in a “warning” field on the primary record (items_tb.item_warnings, recipe_tb.recipe_warnings, etc.).  This way my project is mostly immune to any bugs that slip into the API, but I can still find out about them.</p>","arenanet":false},{"pubDate":"2015-02-02T17:55:50.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4758430","author":"StevenL.3761","body":"\n<p>Dyes and recipes are one of the “interesting” inheritance issues that I was talking about in one of my previous posts. They don’t have their own data structure, but the ‘color_id’ field and the ‘recipe_id’ field depend on ‘unlock_type’ having a specific value.</p>\n<p>With that in mind, you would want to split them out into separate tables just so that you can apply a NOT NULL constraint to these fields.</p>","arenanet":false},{"pubDate":"2015-02-02T16:13:44.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4758075","author":"Dr Ishmael.9685","body":"\n<p>Outer joins are used when you want to append fields from another table, but you still want to retain all records from the driver table. (Inner joins only return records where the join key exists on both tables.) Any records where the join key doesn’t exist on the lookup table will have nulls appended.</p>\n<p>However, constructing a single “master” view to flatten absolutely everything may not be the best approach. Outer joins are less efficient than inner joins, and stacking that many of them into one view will make it very sluggish.</p>\n<p>My approach would be to construct separate views for each primary type, where I would use an inner join on item_id.  Then I would use an outer join for any subtypes.  This mockup assumes that all fields are named uniquely across your tables.  If they’re not, you’ll have to replace the * with an explicit field list with aliases on the duplicate field names.</p>\n<p>CREATE VIEW consumables_vw<br>\nAS<br>\nSELECT *<br>\nFROM [items]<br>\nINNER JOIN [items_consumable] ON [items].[item_id] = [items_consumable].[item_id] <br>\nLEFT OUTER JOIN [items_unlock_dye] ON [items_consumable].[item_id] = [items_unlock_dye].[item_id] <br>\nLEFT OUTER JOIN [items_unlock_recipe] ON [items_consumable].[item_id] = [items_unlock_recipe].[item_id]</p>\n<p>I’m not sure why you have separate tables for dye and (I’m assuming) recipe unlocks, they don’t have any additional data structures.</p>","arenanet":false},{"pubDate":"2015-02-01T17:30:13.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4755376","author":"StevenL.3761","body":"\n<p>Okay… now how do I create a view in SQL that flattens the table hierarchy?</p>\n<p>I don’t know how to join the [items] table with one of the many sub-type tables based on the actual values in the [item_type] column.</p>\n<p>Someone on stackoverflow suggested left outer joins, but it doesn’t look quite right to me<br>\n<a href=\"https://gist.github.com/StevenLiekens/4b66c22ffd1b92e5d498\">https://gist.github.com/StevenLiekens/4b66c22ffd1b92e5d498</a></p>","arenanet":false},{"pubDate":"2015-01-28T02:17:07.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4739446","author":"Killer Rhino.6794","body":"\n<blockquote><div class=\"citey\"><cite title=\"Posted on January 20 2015 09:58PM\"><a href=\"/forum/community/api/Data-Types/4711585\">Lawton Campbell.8517:</a></cite></div><div class=\"quotey\"><p>I’d probably store the attributes of each subtype in a separate table to maximize normalization. e.g., the <code>items</code> table would just store the attributes common to all items; for items with a “consumable” type, the <code>items_consumable</code> table would have the corresponding type-specific fields; and for consumables with an “unlock” type, the <code>items_unlock_dye</code> or <code>items_unlock_recipe</code> would have those details.</p></div></blockquote>\n<p>This is the exact solution I came to in my own applications; gets the job done.</p>\n<p>As an aside: thanks for your ongoing communications in this subforum, Lawton!</p>","arenanet":false},{"pubDate":"2015-01-21T13:44:01.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4713630","author":"Alcarin.9024","body":"\n<p>Yes 29 tables are a lot, but that’s what I got trying to allow flexibility on structure (allowing new types/sub-types to be added dinamically) and querying capability/rapidity (indexing only numeric values). So I’ve not used enum type (if you modify an enum type you need to rebuild the entire table), neither indexed string for types/sub-types, I’ve only used external table with foreign keys.</p>\n<p>This is the link to the sql schema: <a href=\"https://drive.google.com/open?id=0B8vP2yhqUTYEb09sM3JiTmFBRDQ&authuser=0\">https://drive.google.com/open?id=0B8vP2yhqUTYEb09sM3JiTmFBRDQ&amp;authuser=0</a><br>\nI’ve also a MySQL Workbench file if you use that program: <a href=\"https://drive.google.com/open?id=0B8vP2yhqUTYEVmVnN08xcmM3YUE&authuser=0\">https://drive.google.com/open?id=0B8vP2yhqUTYEVmVnN08xcmM3YUE&amp;authuser=0</a></p>\n<p>A really important factor is the use that you need the database for. I was building the DB for a ItemDB website, and filtering by various type was a very crucial operation that need to be fast and fleasible. For many uses in example, it is less important indexing sub-types/sub-sub-types, so they can be a string instead of a foreign key…</p>","arenanet":false},{"pubDate":"2015-01-21T01:05:44.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4712464","author":"Lawton Campbell.8517","body":"\n<blockquote><div class=\"citey\"><cite title=\"Posted on January 20 2015 11:43PM\"><a href=\"/forum/community/api/Data-Types/4712277\">Alcarin.9024:</a></cite></div><div class=\"quotey\"><p>Months ago, I’ve done something similar to your suggestion Lawton, in about 10 hours of work (wiki was not as completed as it is now) I’ve created a DB with 29 tables without armors and weapons.</p></div></blockquote>\n<p>Huh,  29 tables seems a bit high. I’d love to take a look at your schema if you’ve still got it somewhere, as I’m probably forgetting something (working on a personal one right now, estimate around 19 tables).</p>\n<p>A NoSQL solution is definitely more straightforward though, since the data format is so varied.</p>","arenanet":true},{"pubDate":"2015-01-20T23:43:40.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4712277","author":"Alcarin.9024","body":"\n<p>Months ago, I’ve done something similar to your suggestion Lawton, in about 10 hours of work (wiki was not as completed as it is now) I’ve created a DB with 29 tables without armors and weapons. <br>\nAmazed by the amount of work needed to complete the item DB (and by the amazing query needed to only get info about a single item), I’ve started to think “Ok, I’m doing  something wrong”.<br>\nAfter some research I’ve found the solution, I’ve started to use a NoSQL DB that do not have a schema at all. With that kind of DB, I was able to create the PHP code to crawl and replicate GW2 DB in a couple of hours, query also was very easy with all kind of filtering by type/sub-type/sub-sub-type.<br>\nSo StevenL, if you want to completly replicate GW2 DB go with a NoSQL DB, otherwise try to use as much as possible strings instead of subtables or enum, and create a lot of index. These are the easiest way.</p>","arenanet":false},{"pubDate":"2015-01-20T21:58:57.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4711585","author":"Lawton Campbell.8517","body":"\n<p>The API backend don’t have any tables whatsoever.</p>\n<p>I’d probably store the attributes of each subtype in a separate table to maximize normalization. e.g., the <code>items</code> table would just store the attributes common to all items; for items with a “consumable” type, the <code>items_consumable</code> table would have the corresponding type-specific fields; and for consumables with an “unlock” type, the <code>items_unlock_dye</code> or <code>items_unlock_recipe</code> would have those details.</p>\n<p>So for this somewhat contrived example, I would probably use something like —</p>\n<pre><code>\nCREATE TABLE items (\n    item_id INTEGER PRIMARY KEY,\n    item_name TEXT NOT NULL,\n    item_type INTEGER NOT NULL\n    -- etc\n);\n\nCREATE TABLE items_consumable (\n    item_id INTEGER PRIMARY KEY,\n    item_consumable_type INTEGER NOT NULL,\n    item_consumable_desc TEXT,\n    item_consumable_duration INTEGER\n    -- etc\n);\n\nCREATE TABLE items_unlock_dye (\n    item_id INTEGER PRIMARY KEY,\n    item_unlock_color INTEGER NOT NULL\n);\n\n</code></pre>\n<p>(the types/nullability of these fields are from <a href=\"http://wiki.guildwars2.com/wiki/API:2/items\">http://wiki.guildwars2.com/wiki/API:2/items</a>)</p>\n<p>And then, for example, <a href=\"https://api.guildwars2.com/v2/items/20357\">https://api.guildwars2.com/v2/items/20357</a> would have the following values inserted into the tables:</p>\n<pre><code>items(item_id=20357, item_name=\"Ash Dye\", item_type=Consumable)\nitems_consumable(item_id=20357, item_consumable_type=Unlock, ...)\nitems_unlock_dye(item_id=20357, item_unlock_color=474)</code></pre>","arenanet":true},{"pubDate":"2015-01-19T20:36:09.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4706850","author":"StevenL.3761","body":"\n<p>Oh okay. Then it only makes sense for me to allow unbounded strings in my own database.</p>\n<p>One more question: do you use a table per type or a table per hierarchy?</p>\n<p>I’m asking because the items API has some… interesting… inheritance issues. Do you store all items in a single table regardless of the item type? Or do you have a table for each type? What about subtypes?</p>\n<p>The most interesting of all items are probably the unlocker consumables. They have an ‘item_type’, a ‘consumable_type’ and an ‘unlock_type’.</p>","arenanet":false},{"pubDate":"2015-01-19T19:47:30.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4706662","author":"Lawton Campbell.8517","body":"\n<p>Sorry, I meant to suggest using the existing data to infer what constraints can be applied. The backend doesn’t really follow any rules (in particular, string lengths are unbounded), so the existing data is the only thing we have to go by.</p>","arenanet":true},{"pubDate":"2015-01-19T19:06:27.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4706551","author":"StevenL.3761","body":"\n<p>Huh? There’s a better way to store all this data?</p>","arenanet":false},{"pubDate":"2015-01-19T18:48:15.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4706505","author":"Lawton Campbell.8517","body":"\n<p>There isn’t an RDBMS behind the API, so there’s no schema per say. I think the quickest approach is to pull the entire dataset and tinker with it until it makes sense.</p>","arenanet":true},{"pubDate":"2015-01-17T12:36:00.000Z","guid":"http://forum-en.guildwars2.com/forum/community/api/Data-Types/4703552","author":"StevenL.3761","body":"\n<p>This has been suggested before (I don’t remember where), but can we get more information about the data types used by the backend’s database? Replicating a database without the original schema takes a lot of guesswork. I’m talking about data type lengths, nullability (is that a word?), default values, and also any other sort of column constraint.</p>","arenanet":false}]}