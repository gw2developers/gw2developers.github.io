<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>[API Suggestion] MD5 Checksum API</title>
  <meta name="description" content="Learn how to use the GW2 API.">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/forum-backup/API-Suggestion-MD5-Checksum-API/">
  <link rel="alternate" type="application/rss+xml" title="GW2 Developers" href="/feed.xml">
  
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-106748097-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/"><img src="/assets/images/logo.svg"></a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/forum-backup/">Forum Backup</a>
            
          
            
            
            <a class="page-link" href="/guides/">Guides</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">[API Suggestion] MD5 Checksum API</h1>
  </header>

  <div class="post-content">
    


<p class="post-meta">
    Original Url: http://forum-en.guildwars2.com/forum/community/api/API-Suggestion-MD5-Checksum-API
</p>



<h2 id="">Kaz.5430:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T01:00:17+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<p>I’ve been considering making a project using some of the API’s, but I’d cache the output to prevent unnecessary calls to the API</p>
<p>A lot of the API results contain a lot of data.</p>
<p>Downloading and parsing that data is pointless if I’ve already cached the output and nothing has changed.</p>
<p>It would be nice if all api variations could have a checksum to identify the content output, without actually calling the particular api</p>
<p>i.e.</p>
<p>I have a script that uses the items api, I see from the build id, that the build has changed but don’t know if it’s just a bug fix, or new items have been added.</p>
<p>Instead of calling the items api and parsing everything again, I call the checksum api to see if the items output has actually changed from when I last called it.</p>
<p>This would also be useful for map details, dyes, objectives etc</p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T06:39:46+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<p>Instead of finding out if it is changed, why don’t you just pass the cached value back along with the age of the cached value.</p>
<p>Some clients may not mind an older value, sometimes, in return for a faster response time.  How about creating a meta server that accepts a max_age, maximum age cached value parameter along with the web api call?  If the meta server can satisfy the request on its own, then it will return its own cached value.  Otherwise, it would have to fetch it from the other meta servers, or the ArenaNet server.</p></p>

<h2 id="">famfamfam.9137:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T07:33:24+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<p>As I currently see it, most of the endpoints are one of the following:</p>
<ul>
	<li>Would be expected to be different if called even within a few seconds of each other (so API-client caching isn’t helpful other than as a method of rate-limiting)<br>
OR</li>
	<li>Fairly reliably on build change. There might be some instances where a new game build does not update these data, but the game doesn’t update often enough that I can see it hurting to hit an essentially static resource and re-parse it.</li>
</ul>
<p>If this <strong>is</strong> implemented API-side, it would make much more sense for it to be handled by ETags, If-None-Match and 304 responses. HTTP is a complex yet wonderful beast: <a href="http://www.mnot.net/cache_docs/">http://www.mnot.net/cache_docs/</a></p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T08:04:04+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 08 2013 07:33AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2368194">famfamfam.9137:</a></cite></div><div class="quotey"><p>If this <strong>is</strong> implemented API-side, it would make much more sense for it to be handled by ETags, If-None-Match and 304 responses. HTTP is a complex yet wonderful beast: <a href="http://www.mnot.net/cache_docs/">http://www.mnot.net/cache_docs/</a></p></div></blockquote>
<p>But as stated in your link, that is not a trivial task.  Furthermore only arenanet origin servers would know if the content has changed so clients would have to query it.  And if the request is authenticated or secure (i.e. https) it won’t be cached.</p>
<p>Clients may not always need the most up-to-date response, so I prefer to leave it to the clients to decide what they need.  As mentioned in your link, ETags are useful in the case of serving static contents (i.e. files).  However, the web server may not know enough about the dynamic content to generate them.</p></p>

<h2 id="">Kaz.5430:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T21:17:47+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<p>I’m talking about caching in the context of storing the parsed json responses in a local relational database so that you can query that database for frequently requested content, instead of asking the server for the same response over and over.</p>
<p>The build updates any time a bug is hotfixed, so a new build doesn’t mean that there have been changes to whatever you’re querying the API for.</p>
<p>As I see it, any efficient script that has anything to do with items or maps should be storing the information locally but checking that the copy it has stored is still valid. There is absolutely no point in calling a 200KB script if the contents have not changed. Sure that might be easier, but I prefer efficiency to ease.</p>
<p>Calling an API and getting a 32 character MD5 checksum as the response, is far more efficient than calling the API itself and getting a 200KB response. Especially if it turns out to be the same 200KB response it gave you last time.</p>
<p>e.g.</p>
<p><a href="https://api.guildwars2.com/md5.json?api=https%3A%2F%2Fapi.guildwars2.com%2Fv1%2Fmaps.json">https://api.guildwars2.com/md5.json?api=https%3A%2F%2Fapi.guildwars2.com%2Fv1%2Fmaps.json</a></p>
<p>It would be very simple to implement, you pass a urlencoded api URL to the MD5 API, it loads the script on the ANet servers, hashes the results and sends you the hash instead of the full json response. You compare the hash to the version you’ve cached, if it’s different, you download the full 200KB.</p>
<p>It could be further optimized if ANet stored timestamp and update information with the hashes it gives out, and you could then call and API and just  get changes to the response since the hash to parse, rather than the entire response.</p>
<p>e.g.</p>
<p><a href="https://api.guildwars2.com/v1/items.json?hash=32bhgdfyh125abhrfhj67k0dvns15d4g">https://api.guildwars2.com/v1/items.json?hash=32bhgdfyh125abhrfhj67k0dvns15d4g</a></p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-08T21:38:51+00:00">
        08 Jul 2013
    </time>
</p>
<p>
<p>I agree that a new build doesn’t mean that there have been changes to whatever you’re querying the API for.  The term “new build” can be ambiguous because I presume that ArenaNet has server and client builds and that they can patch their servers without needing to patch clients and vice versa.  I may be wrong, but this would mean that client and server can have different build numbers and each can have a ‘new build’ at different times.</p>
<p>What you are proposing would be similar to the ETags feature mentioned by famfamfam.  I have a few questions about your proposal:</p>
<p>1.  What if certain api responses are fewer than 32 characters?  Wouldn’t it be more efficient to just return the response than generating the MD5 checksum, and then returning them?</p>
<p>2.  What about those APIs whose responses change often?  Wouldn’t generating the MD5 checksum be quite redundant in those cases and be a further hit to the server performance?</p>
<p>3.  Does this require all clients to be able to generate MD5 checksums from server responses or for the server to always return the MD5 checksum with each of its responses?  If it is the former, that would be additional restrictions on the clients.  If it is the latter, then the clients would have to remember and manage checksums.</p>
<p>4.  What are the advantages/disadvantages of this approach over ETags?</p></p>

<h2 id="">Healix.5819:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T02:49:07+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<p>They try to avoid processing with the API. Having a checksum option would most likely require them to constantly recalculate it since the API itself probably doesn’t know when it has been changed. It probably just reads the data directly and returns the response. With the amount of requests they receive, it’s not feasible to calculate the sum with every request. That would mean they would have to calculate it every so often, which would open up problems where the data has changed but the sum has not. It wouldn’t really matter though, since you don’t need up to the millisecond data.</p>
<p>A 3rd party site could provide this functionality. Sites like gwstats.net are already constantly checking some of the APIs~, so sites like those could also provide a checksum or modified since.</p>
<p>Checking the build is meaningless when it comes to new data. Remember, the data is only available once it is found. That means items might now show up for days or even months after a new build is introduced. If any items are changed however, they will be changed with a build.</p>
<p>The only advantage to using “md5.json?=” over a etag or modified since header is that they could hope nobody uses it so they wouldn’t have to calculate the checksum. The obvious downside is that it would take 2 requests  to download something, whereas with the header tags, the server would stop or continue the response. The problem with additional headers is that it further bloats responses.</p>
<blockquote><div class="citey"><cite title="Posted on July 08 2013 09:38PM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2372393">DarkSpirit.7046:</a></cite></div><div class="quotey"><p>1.  What if certain api responses are fewer than 32 characters?  Wouldn’t it be more efficient to just return the response than generating the MD5 checksum, and then returning them?</p></div></blockquote>
<p>When requesting the status of a single event, the response header is around the same size as the data. Furthermore, if you request it to be gzipped, the response is bloated, becoming larger than it would be uncompressed. Cases where efficiency is lost already exist.</p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T03:17:38+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 09 2013 02:49AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2373820">Healix.5819:</a></cite></div><div class="quotey"><p>A 3rd party site could provide this functionality. Sites like gwstats.net are already constantly checking some of the APIs~, so sites like those could also provide a checksum or modified since.</p></div></blockquote>
<p>The problem with gw2stats.net is that it shows the response times with reference from only one particular server.  Furthermore, they do not cache and provide API responses back to other clients (only API statuses), so it is somewhat of a wasted bandwidth.</p>
<p>If we have a number of servers across the world that would cache and redistribute API responses that would have been more useful since the more popular responses would tend to be cached.  With enough caches, even if the anet origin server goes down, clients can still operate in  a limited fashion.</p></p>

<h2 id="">Drakma.1549:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T04:01:00+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 09 2013 03:17AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2373917">DarkSpirit.7046:</a></cite></div><div class="quotey"><blockquote><div class="citey"><cite title="Posted on July 09 2013 02:49AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2373820">Healix.5819:</a></cite></div><div class="quotey"><p>A 3rd party site could provide this functionality. Sites like gwstats.net are already constantly checking some of the APIs~, so sites like those could also provide a checksum or modified since.</p></div></blockquote>
<p>The problem with gw2stats.net is that it shows the response times with reference from only one particular server.  Furthermore, they do not cache and provide API responses back to other clients (only API statuses), so it is somewhat of a wasted bandwidth.</p>
<p>If we have a number of servers across the world that would cache and redistribute API responses that would have been more useful since the more popular responses would tend to be cached.  With enough caches, even if the anet origin server goes down, clients can still operate in  a limited fashion.</p></div></blockquote>
<p>I’ve actually been thinking of adding something like this to gw2stats.net since I implemented the API status tool.</p>
<p>However, this is no small task.  For example, I have been caching the data since May 29th (shortly after the API was released) and the amount of data is staggering.  So staggering it’s at the point where I’m seriously having to consider moving hosts.</p>
<p>For example, the WvW data alone is 18GB without indexes in the database.  Indexes add another 6GB.  Now I realise I wouldn’t have to have that sort of retention for a simple checksum API, but the number of records alone that would have to be checked constantly numbers in the millions.</p>
<p>The events.json alone is 422,000 elements. There are over 26,000 items that would need to be checked constantly in the item_details.json call alone. To compare each item to an old version would take approximately 8 hours with the speed of the API, data storage, and latency added in.</p>
<p>That being said, there are some things that can be done pragmatically that should help you out.  For instance, you will almost always have to pull some APIs live each time instead of checking to see if they changed.  Some of those off the top of my head are match_details.json, events.json, match_details.json and guild_details.json.  Some calls even give you a timestamp on when you should check for an update next (matches.json).</p>
<p>In addition to the above, I also have some tricks that help to keep the data up-to-date.  For instance, when a user uses my website to view item information, it will first check the API to see if the data has changed.  If it has, it updates it before it presents it to the user.  This keeps the frequently accessed data refreshed and the seldom or never accessed data the same.  Lower bandwidth, less overhead.</p>
<p>I’ll try to wrap this up here as this post has become longer than I expected, but.  I will attempt to make a checksum API for less “active” data to see if that is something that will be useful.</p>
<p>Finally, you mentioned that gw2stats.net is only one frame of reference.  You are absolutely correct.  I would love to be able to provide a service where you can run a script on your side and have it send data to gw2stats.net for a more “worldwide” representation of access to the GW2 API.  If there is interest in that, I will be more than happy to provide it.</p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T04:44:47+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 09 2013 04:01AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2374086">Drakma.1549:</a></cite></div><div class="quotey"><p>In addition to the above, I also have some tricks that help to keep the data up-to-date.  For instance, when a user uses my website to view item information, it will first check the API to see if the data has changed.  If it has, it updates it before it presents it to the user.  This keeps the frequently accessed data refreshed and the seldom or never accessed data the same.  Lower bandwidth, less overhead.</p></div></blockquote>
<p>By “user” you only meant a HTML browser right?  From your website, the only JSON API you exposed are the ones for API statuses.  Would you be planning to introduce JSON APIs on your website for clients to access your caches?  You probably do not need to cache too far into the past.  Furthermore, each server (including yours) do not need to support all of the APIs, as they can pick and choose which API they want to cache and re-propagate to requesting clients.  We can share the load.  You can also allocate your resources dynamically based on demand.</p>
<blockquote><div class="quotey"><p>Finally, you mentioned that gw2stats.net is only one frame of reference.  You are absolutely correct.  I would love to be able to provide a service where you can run a script on your side and have it send data to gw2stats.net for a more “worldwide” representation of access to the GW2 API.  If there is interest in that, I will be more than happy to provide it.</p></div></blockquote>
<p>Or you can just share the parts of your code for the caching and status calculations so that every server would be processing them in the same way.  There would be less work for you this way.</p></p>

<h2 id="">Drakma.1549:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T06:03:30+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<p>OK, I think I get it now.  You’re basically looking for an API CDN. I, honestly would worry about aging data as it moved across ‘net.  Some of the data literally changes multiple times per second.  I really don’t know how that would work out.</p>
<p>But, I’ll try to answer your questions in order.</p>
<p>- Yes, by “user” I mean an HTML browser<br>
- Yes, I am planning on releasing a JSON (and possibly CSV) API</p>
<p>As far as only caching what I need, I do that now.  There is not a single API that I don’t use currently so I end up caching them all.  But as I said previously, I don’t always cache the everything (specifically the lesser used items/recipes).</p>
<p>I’m hesitant to release my code (honestly) only because I am a casual programmer.  Back in the day, I was a pretty hard-core Perl, C/C++ programmer, but those days are long gone.  I set out to learn PHP and JS with this project so I am quite sure that my code would look horrendous in the eyes of some “real” programmers.</p>
<p>However, I am more than happy to talk about my methodologies and even calculations that I use.</p>
<p>Quite basically, I retrieve what I need as often as I possibly can. With the exception of one call, I always put the daemon program to “sleep” for a short period of time before it just continues on refreshing the data.  That one exception is match_details.json.  I literally pull that as often as can be pulled for the sheer fact that I maintain a Live Map of WvW objectives.</p>
<p>As far as status calculations are concerned, that’s pretty simple.  I already proved that information in the status_codes.json from my site.  Viewing <a href="http://gw2stats.net/api/status_codes.json">http://gw2stats.net/api/status_codes.json</a> should tell you what I do for calculations.</p>
<p>As far as what I do pragmatically, it’s quite simple (This is what I do in PHP):</p>
<p>1) Start a timer<br>
2) Fetch the latest API using curl.<br>
3) Stop timer and calculate difference from Step 1 in millisends: This becomes retrieval time.<br>
3) Using json_decode, I convert the raw json to an array.<br>
4) Using count(), I count the total number of elements in the array (this includes nesting)<br>
5) Ping the specified API domain (return -1 if down)<br>
6) This all get’s thrown into MySQL<br>
7) API is a live pull from the MySQL database</p>
<p>I’m really enjoying this thread.  It’s making me think about the way I do some things and sometimes I just like to talk “nerd.”</p></p>

<h2 id="">Kaz.5430:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T16:16:07+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<p>With a header-based solution, I think ANet still has to generate the response and my server still has to download it.</p>
<p>Unless of course I was to implement some sort of apache level solution that would intelligently parse the header and then break the connection some how. I’m not sure on the technical side of that, but I’d assume that the ANet server still needs to generate the content and probably upload it. All I’m doing is using API server resources, and then binning the output because I don’t need it.</p>
<p>If ANet are generating and uploading the json response anyway, and I’m downloading it anyway then I could just take an md5 hash from the download and do the checksum comparison locally. The whole point is to prevent ANet parsing and uploading superfluous data, and then my server downloading it.</p>
<p>On the subject of ‘what if the response was smaller than 32 characters’. It wouldn’t have to be an MD5 hash, a smaller length CRC hash would probably work just as well, so would the size of the output in bits, or a unix timestamp. MD5 was literally the first thing I thought of, and I could imagine how ANet might implement the API. However, if you’re expecting less data than the hash, you’d not bother asking for the hash because doing so would not be beneficial to either the ANet API sever, nor your own.</p>
<p>Sending a hash with every request is also over-kill. The API server would need to be constantly using resources to generate a value that a lot of people would ignore anyway. This idea is more for larger apps that ask for a lot of content that doesn’t change all that much. You’d hope it would be the larger apps that have more users that take advantage of the caching options, in order to speed up their app.</p>
<p>If the API services take off, then eventually ANet will need to implement some form of authentication and query limiting solution. Amazon for example limits authenticated users to 2000 queries an hour (plus additional queries based on how much they sell) and after that queries will produce a 503 error until the next hour. That’s basically 1 query every 2 seconds. Scripts using the map API – especially if combined with real-time event status for every map on every server – are likely to bring about the need for rate limiting quicker, unless people implement local caching.</p>
<p>Lets say you have a map script in which every time a user zooms or moves to generate a new view of the map, it calls <a href="https://api.guildwars2.com/v1/map_floor.json?continent_id=1&floor=1">https://api.guildwars2.com/v1/map_floor.json?continent_id=1&amp;floor=1</a>. That’s currently a 427KB document that has probably not changed between calls. Likewise calling all the individual tiles adds up to a lot of upload from the API server and – depending on implementation – download to the client, and possibly your server.</p>
<p>Now lets imagine your app has 500 concurrent users, all requesting the 427KB map response and a selection of tiles simultaneously and repetitively. Caching the map information and images locally would likely lead to a faster experience for your app, and would equate to far less load on the API server.</p>
<p>The information that comes in large responses is pretty much static. Having some way of querying to see if anything in the world map has changed, to establish if the api is returning more information for a map, or to see if a tile jpg has been changed – without having to downloading the lot – would be significantly faster and reduce load.</p>
<p>To me, whether this functionality is provided as an MD5 api, or something else doesn’t really matter all that much. An MD5 hash was just what came to mind first.</p></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T16:26:23+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<p>Thanks Drakma.  I think you did excellent work on your website and many people (myself included) posted worse code publicly as our learning attempts.</p>
<p>I enjoy this thread too, it gives me the chance to vent what I have always had in my mind, without actually finding time in my busy schedules to do the work.</p></p>

<h2 id="">Healix.5819:</h2>
<p class="post-meta">
    <time datetime="2013-07-09T19:41:30+00:00">
        09 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 09 2013 04:16PM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2377233">Kaz.5430:</a></cite></div><div class="quotey"><p>Lets say you have a map script in which <strong>every time a user zooms or moves</strong> to generate a new view of the map, it calls <a href="https://api.guildwars2.com/v1/map_floor.json?continent_id=1&floor=1">https://api.guildwars2.com/v1/map_floor.json?continent_id=1&amp;floor=1</a>.</p></div></blockquote>
<p>I hope that’s just an example. Requesting static data should only be done once, when the app initializes.</p>
<p>Map tile images already implement an “md5 checksum” using headers. When using these headers, in your request, you supply your checksum and then the server makes a comparison. If they match, the server returns just a header stating that the content was not modified and if they don’t match, the request occurs like normal.</p>
<p>The actual request headers are “If-Modified-Since: <em>x</em>” or “If-None-Match: <em>y</em>” where <em>x</em> and <em>y</em> are from the response headers “Last-Modified: <em>x</em>” and “ETag: <em>y</em>”.</p></p>

<h2 id="">famfamfam.9137:</h2>
<p class="post-meta">
    <time datetime="2013-07-10T06:40:07+00:00">
        10 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 09 2013 04:16PM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2377233">Kaz.5430:</a></cite></div><div class="quotey"><p>Unless of course I was to implement some sort of apache level solution that would intelligently parse the header and then break the connection some how.</p></div></blockquote>
<p>This is exactly how HTTP works: <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5</a> (I’d highly recommend the HTTP spec as some light reading by the way, it was a fantastic eye-opener when I read through it all<img src="/include/images/smilies/smile.png">).</p>
<blockquote><div class="citey"><cite title="Posted on July 08 2013 08:04AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2368307">DarkSpirit.7046:</a></cite></div><div class="quotey"><p>But as stated in your link, that is not a trivial task.  Furthermore only arenanet origin servers would know if the content has changed so clients would have to query it.  And if the request is authenticated or secure (i.e. https) it won’t be cached.</p></div></blockquote>
<p>These are not concerns.</p>
<p>1. Authenticated requests should be cached according to the outgoing Vary.<br>
2. HTTPS is cached client-side by default providing no Cache-Control/Pragma headings say otherwise.</p>
<blockquote><div class="citey"><cite title="Posted on July 08 2013 08:04AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2368307">DarkSpirit.7046:</a></cite></div><div class="quotey"><p>Clients may not always need the most up-to-date response, so I prefer to leave it to the clients to decide what they need.  As mentioned in your link, ETags are useful in the case of serving static contents (i.e. files).  However, the web server may not know enough about the dynamic content to generate them.</p></div></blockquote>
<p>The API servers are the authority for the data, so therefore should also be also be the authority for the allowed staleness of the data.</p>
<p>That said, I don’t think the API needs this at all:</p>
<ul>
	<li>For fast-moving data (events, WvW objective status) you should treat the API as being realtime. No revision information needed.</li>
	<li>If you’re concerned about re-running your code on the slower-moving data (items/etc), just make a request every so often and compare MD5 hashes of the body response locally; its a lot of work to implement document versioning via ETags/Revision APIs when its something that you won’t be requesting very often anyway. Or just re-parse it every time anyway, and optimise it only when you need to?</li>
</ul></p>

<h2 id="">DarkSpirit.7046:</h2>
<p class="post-meta">
    <time datetime="2013-07-10T18:03:35+00:00">
        10 Jul 2013
    </time>
</p>
<p>
<blockquote><div class="citey"><cite title="Posted on July 10 2013 06:40AM"><a href="/forum/community/api/API-Suggestion-MD5-Checksum-API/2382201">famfamfam.9137:</a></cite></div><div class="quotey"><p>The API servers are the authority for the data, so therefore should also be also be the authority for the allowed staleness of the data.</p></div></blockquote>
<p>That may make sense with a traditional web server, serving static content from files but it may not make as much sense here.  The problem with that is, does ArenaNet web server even know what the allowed staleness of the data should be?  Even their items and recipes depend on their discovery by players, so how is their web server suppose to know when the responses are going to change?</p>
<p>This is why I suggested that the clients would be in a better position to know what they would be using the responses for and for some tasks, they really do not need the latest data.  Furthermore, they always have the choice to get the latest data if they want to, but perhaps at the cost of a longer response time.</p></p>


  </div>

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">GW2 Developers</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              GW2 Developers
            
            </li>
            
            <li><a href="mailto:gw2developers@darthmaim.de">gw2developers@darthmaim.de</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/gw2developers"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">gw2developers</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/gw2api"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">gw2api</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Learn how to use the GW2 API.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
